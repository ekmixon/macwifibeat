#!/usr/bin/env python
"""Cherry pick and backport a PR"""

import sys
import os
import argparse
from os.path import expanduser
import re
from subprocess import check_call, call, check_output
import requests

usage = """
Example usage:

./dev-tools/cherrypick_pr --create_pr 5.0 2565 6490604aa0cf7fa61932a90700e6ca988fc8a527

In case of backporting errors, fix them, then run:

git cherry-pick --continue
./dev-tools/cherrypick_pr --create_pr 5.0 2565 6490604aa0cf7fa61932a90700e6ca988fc8a527 --continue

This script does the following:

* cleanups both from_branch and to_branch (warning: drops local changes)
* creates a temporary branch named something like "branch_2565"
* calls the git cherry-pick command in this branch
* after fixing the merge errors (if needed), pushes the branch to your
  remote
* if the --create_pr flag is used, it uses the GitHub API to create the PR
  for you. Note that this requires you to have a Github token with the
  public_repo scope in the `~/.elastic/github.token` file

Note that you need to take the commit hashes from `git log` on the
from_branch, copying the IDs from Github doesn't work in case we squashed the
PR.
"""


def main():
    """Main"""
    parser = argparse.ArgumentParser(
        description="Creates a PR for cherry-picking commits",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=usage)
    parser.add_argument("to_branch",
                        help="To branch (e.g 5.0)")
    parser.add_argument("pr_number",
                        help="The PR number being merged (e.g. 2345)")
    parser.add_argument("commit_hashes", metavar="hash", nargs="+",
                        help="The commit hashes to cherry pick." +
                        " You can specify multiple.")
    parser.add_argument("--yes", action="store_true",
                        help="Assume yes. Warning: discards local changes.")
    parser.add_argument("--continue", action="store_true",
                        help="Continue after fixing merging errors.")
    parser.add_argument("--from_branch", default="master",
                        help="From branch")
    parser.add_argument("--create_pr", action="store_true",
                        help="Create a PR using the Github API " +
                        "(requires token in ~/.elastic/github.token)")
    parser.add_argument("--diff", action="store_true",
                        help="Display the diff before pushing the PR")
    args = parser.parse_args()

    print(args)

    tmp_branch = f"backport_{args.pr_number}_{args.to_branch}"

    if not vars(args)["continue"]:
        if not args.yes and raw_input("This will destroy all local changes. " +
                                      "Continue? [y/n]: ") != "y":
            return 1
        check_call("git reset --hard", shell=True)
        check_call("git clean -df", shell=True)
        check_call("git fetch", shell=True)

        check_call(f"git checkout {args.from_branch}", shell=True)
        check_call("git pull", shell=True)

        check_call(f"git checkout {args.to_branch}", shell=True)
        check_call("git pull", shell=True)

        call(f"git branch -D {tmp_branch} > /dev/null", shell=True)
        check_call(f"git checkout -b {tmp_branch}", shell=True)
        if (
            call(
                f'git cherry-pick -x {" ".join(args.commit_hashes)}',
                shell=True,
            )
            != 0
        ):
            print("Looks like you have cherry-pick errors.")
            print("Fix them, then run: ")
            print("    git cherry-pick --continue")
            print(f'    {" ".join(sys.argv)} --continue')
            return 1

    if len(check_output("git status -s", shell=True).strip()) > 0:
        print("Looks like you have uncommitted changes." +
              " Please execute first: git cherry-pick --continue")
        return 1

    if (
        len(
            check_output(
                f"git log HEAD...{args.to_branch}", shell=True
            ).strip()
        )
        == 0
    ):
        print("No commit to push")
        return 1

    if args.diff:
        call(f"git diff {args.to_branch}", shell=True)
        if raw_input("Continue? [y/n]: ") != "y":
            print("Aborting cherry-pick.")
            return 1

    print("Ready to push branch.")
    remote = raw_input("To which remote should I push? (your fork): ")
    call(f"git push {remote} :{tmp_branch} > /dev/null", shell=True)
    check_call(f"git push --set-upstream {remote} {tmp_branch}", shell=True)
    if not args.create_pr:
        print(
            (
                "Done. Open PR by following this URL: \n\t"
                + f"https://github.com/elastic/beats/compare/{args.to_branch}...{remote}:{tmp_branch}?expand=1"
            )
        )

    else:
        token = open(expanduser("~/.elastic/github.token"), "r").read().strip()
        base = "https://api.github.com/repos/elastic/beats"
        session = requests.Session()
        session.headers.update({"Authorization": f"token {token}"})

        original_pr = session.get(f"{base}/pulls/{args.pr_number}").json()

        # get the github username from the remote where we pushed
        remote_url = check_output(f"git remote get-url {remote}", shell=True)
        remote_user = re.search("github.com:(.+)/beats", remote_url)[1]

        # create PR
        request = session.post(
            f"{base}/pulls",
            json=dict(
                title=f'Cherry-pick #{args.pr_number} to {args.to_branch}: {original_pr["title"]}',
                head=f"{remote_user}:{tmp_branch}",
                base=args.to_branch,
                body=f'Cherry-pick of PR #{args.pr_number} to {args.to_branch} branch. Original message: \n\n{original_pr["body"]}',
            ),
        )

        if request.status_code > 299:
            print(f"Creating PR failed: {request.json()}")
            sys.exit(1)
        new_pr = request.json()

        # add labels
        session.post(
            base + f'/issues/{new_pr["number"]}/labels',
            json=["backport", "review"],
        )


        # remove needs backport label from the original PR
        session.delete(base + f"/issues/{args.pr_number}/labels/needs_backport")

        if version := get_version(os.getcwd()):
            session.post(base + f"/issues/{args.pr_number}/labels", json=[f"v{version}"])

        print(f'\nDone. PR created: {new_pr["html_url"]}')
        print("Please go and check it and add the review tags")

def get_version(beats_dir):
    pattern = re.compile(r'(const\s|)\w*(v|V)ersion\s=\s"(?P<version>.*)"')
    with open(os.path.join(beats_dir, "libbeat/version/version.go"), "r") as f:
        for line in f:
            if match := pattern.match(line):
                return match['version']


if __name__ == "__main__":
    sys.exit(main())
